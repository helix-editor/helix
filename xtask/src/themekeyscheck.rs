use std::collections::BTreeMap;
use std::fmt::Write;

use helix_core::syntax::read_query;
use helix_core::tree_sitter::Query;
use helix_loader::grammar::get_language;

use crate::helpers::lang_config;

pub fn theme_keys_check() -> Result<(), String> {
    let highlight_queries_file = "highlights.scm";
    let mut highlights_queries: BTreeMap<_, Vec<_>> = BTreeMap::new();

    for language in lang_config().language {
        let language_name = language.language_id.to_ascii_lowercase();
        let grammar_name = language.grammar.unwrap_or(language.language_id);
        let language = get_language(&grammar_name);
        let query_text = read_query(&language_name, highlight_queries_file);
        if let (false, Ok(language)) = (query_text.is_empty(), language) {
            match Query::new(language, &query_text) {
                Err(reason) => {
                    return Err(format!(
                        "Failed to parse {} queries for {}: {}",
                        highlight_queries_file, language_name, reason
                    ))
                }
                Ok(query) => {
                    let filtered_names = query.capture_names().iter().filter(|cn| {
                        !(cn.contains("._")
                            || cn.contains("__")
                            || cn.contains("_.")
                            || cn.starts_with('_'))
                    });
                    for capture_name in filtered_names {
                        highlights_queries
                            .entry(capture_name.clone())
                            .or_default()
                            .push(language_name.clone());
                    }
                }
            }
        }
    }

    let mut has_error = false;
    for (hq, langs) in highlights_queries {
        if !is_known_key(&hq) {
            eprintln!(
                "'{}' is not a static theme key (seen in languages: {:?}) ",
                hq, langs
            );
            has_error = true;
        }
    }

    if has_error {
        Err("Theme key are incomplete, add missing keys to the list in `themekeyscheck.rs`".into())
    } else {
        println!("All theme keys found in highlight queries are known !");
        Ok(())
    }
}

/// Generate the doc table for `book/src/theme.md`
pub fn theme_keys_doc() -> String {
    let mut table = String::from(
        "<!-- DO NOT MODIFY MANUALLY: Document generated by xtask::themekeyscheck::theme_keys_doc() using `cargo xtask docgen` -->",
    );

    write_table_for_keys_and_doc(&mut table, "UI-only Keys", UI_KEY_DOCS);
    write_table_for_keys_and_doc(&mut table, "Mixed Keys (UI & Languages)", MIXED_KEY_DOCS);
    write_table_for_keys_and_doc(&mut table, "Language-only keys", LANG_KEY_DOCS);

    table.push('\n');
    table.push_str("[e-sec]: ./configuration.md#editor-section\n");
    table.push_str("[e-sl-sec]: ./configuration.md#editorstatusline-section\n");
    table.push_str("[e-ig-sec]: ./configuration.md#editorindent-guides-section\n");
    table.push_str("[e-ws-sec]: ./configuration.md#editorwhitespace-section\n");

    table
}

fn write_table_for_keys_and_doc(
    table: &mut String,
    header: &str,
    keys_docs: &[(&'static str, &'static str)],
) {
    fn max_size(header: &str, lengths: &[(&'static str, &'static str)]) -> (usize, usize) {
        lengths
            .iter()
            .fold((header.len(), 0), |(km, nm), (kl, nl)| {
                (km.max(kl.len()), nm.max(nl.len()))
            })
    }

    let (keys_w, notes_w) = max_size(header, keys_docs);

    table.push('\n');
    writeln!(
        table,
        "| {k:kw$} | {n:nw$} |",
        k = header,
        kw = keys_w,
        n = "Notes",
        nw = notes_w
    )
    .unwrap();
    writeln!(
        table,
        "| {k:kw$} | {n:nw$} |",
        k = "---",
        kw = keys_w,
        n = "---",
        nw = notes_w
    )
    .unwrap();

    for (key, doc) in keys_docs {
        writeln!(
            table,
            "| {k:kw$} | {d:nw$} |",
            k = key,
            kw = keys_w,
            d = doc,
            nw = notes_w
        )
        .unwrap();
    }
}

/// Keys must be given in the following order:
///
/// - UI keys (used only in UI theming)
/// - Mixed keys (used both for language and UI theming)
/// - Language keys (used only in language theming)
macro_rules! generate_theme_keys {
    (
        UI KEYS;
        $($ui_key: literal, $ui_doc: literal,)+

        MIXED KEYS;
        $($mixed_key: literal, $mixed_doc: literal,)+

        LANGUAGE KEYS;
        $($lang_key: literal, $lang_doc: literal,)+
    ) => {
        fn is_known_key(key: &str) -> bool {
            match key {
                $(| $ui_key)+
                $(| $mixed_key)+
                $(| $lang_key)+ => true,
                _ => false,
            }
        }

        const UI_KEY_DOCS: &[(&str, &str)] = &[
            $( (concat!("`", $ui_key, "`"), $ui_doc) ),+
        ];

        const MIXED_KEY_DOCS: &[(&str, &str)] = &[
            $( (concat!("`", $mixed_key, "`"), $mixed_doc) ),+
        ];

        const LANG_KEY_DOCS: &[(&str, &str)] = &[
            $( (concat!("`", $lang_key, "`"), $lang_doc) ),+
        ];
    };
}

// Alphabetical order should be respected as much as possible when it makes sense (within a section),
// to make maintenance easier and the generated documentation clearer in the Helix book.
//
// Keys must be given in the following order:
//
// - UI keys (used only in UI theming)
// - Mixed keys (used both for language and UI theming)
// - Language keys (used only in language theming)
//
// ADDING A KEY: remember to run `cargo xtask docgen` to avoid being blocked by a
// failing test in CI.
generate_theme_keys!(
    // -- UI ONLY KEYS
    UI KEYS;

    // Diagnostic stuff, in alphabetical order
    "diagnostic"        , "Diagnostics fallback style (editing area)",
    "diagnostic.error"  , "Diagnostic error (editing area)",
    "diagnostic.hint"   , "Diagnostic hint (editing area)",
    "diagnostic.info"   , "Diagnostic info (editing area)",
    "diagnostic.warning", "Diagnostic warning (editing area)",
    "error"             , "Diagnostic error (gutter area, see [`editor.gutters`][e-sec])",
    "hint"              , "Diagnostic hint (gutter area, see [`editor.gutters`][e-sec])",
    "info"              , "Diagnostic info (gutter area, see [`editor.gutters`][e-sec])",
    "warning"           , "Diagnostic warning (gutter area, see [`editor.gutters`][e-sec])",

    // UI for Helix, in alphabetical order
    "ui"                             , "Fallback style for all UI",
    "ui.background"                  , "Default background",
    "ui.background.separator"        , "Picker separator below imput line",
    "ui.bufferline"                  , "Fallback for bufferline (see [`editor.bufferline`][e-sec])",
    "ui.bufferline.active"           , "Active buffer in bufferline (see [`editor.bufferline`][e-sec])",
    "ui.bufferline.background"       , "Background of whole bufferline (see [`editor.bufferline`][e-sec])",
    "ui.cursor"                      , "Fallback cursor style",
    "ui.cursor.insert"               , "Insert-mode cursor (superseded by `ui.cursor.primary`)",
    "ui.cursor.match"                , "Matching bracket, etc.",
    "ui.cursor.primary"              , "Primary cursor (the one left when a multi-cursor ends)",
    "ui.cursor.primary.insert"       , "Primary cursor in Insert mode (the one left when a multi-cursor ends)",
    "ui.cursor.primary.normal"       , "Primary cursor in Normal mode (the one left when a multi-cursor ends)",
    "ui.cursor.primary.select"       , "Primary cursor in Select mode (the one left when a multi-cursor ends)",
    "ui.cursor.select"               , "Select-mode cursor (superseded by `ui.cursor.primary`)",
    "ui.cursorcolumn"                , "Fallback style for columns with cursors (see [`editor.cursorcolumn`][e-sec])",
    "ui.cursorcolumn.primary"        , "Column of the primary cursor (see [`editor.cursorcolumn`][e-sec])",
    "ui.cursorcolumn.secondary"      , "Column of any other cursor (see [`editor.cursorcolumn`][e-sec])",
    "ui.cursorline"                  , "Fallback style for lines with cursors (see [`editor.cursorline`][e-sec])",
    "ui.cursorline.primary"          , "Line of the primary cursor (see [`editor.cursorline`][e-sec])",
    "ui.cursorline.secondary"        , "Line of any other cursor (see [`editor.cursorline`][e-sec])",
    "ui.gutter"                      , "Gutters default style (see [`editor.gutters`][e-sec])",
    "ui.gutter.selected"             , "Gutter style for lines with a cursor (see [`editor.gutters`][e-sec])",
    "ui.help"                        , "Description box for commands",
    "ui.highlight"                   , "Stack frame and selected lines in files in pickers",
    "ui.linenr"                      , "Line number (see [`editor.gutters`][e-sec])",
    "ui.linenr.selected"             , "Line number for lines with a cursor (see [`editor.gutters`][e-sec] & [`editor.cursorline`][e-sec])",
    "ui.menu"                        , "Code and command completion menus",
    "ui.menu.scroll"                 , "`fg` sets thumb color, `bg` sets track color of scrollbar",
    "ui.menu.selected"               , "Selected autocomplete item",
    "ui.popup"                       , "Documentation popup (e.g. `Space + k` in defaults bindings)",
    "ui.popup.info"                  , "Prompt for multiple key options",
    "ui.selection"                   , "Selections in the editing area",
    "ui.selection.primary"           , "Primary selection in the editing area",
    "ui.statusline"                  , "Default style for the statusline (see [`editor.statusline`][e-sl-sec])",
    "ui.statusline.active"           , "Statusline of focused document (see [`editor.statusline`][e-sl-sec])",
    "ui.statusline.inactive"         , "Statusline of unfocused document (see [`editor.statusline`][e-sl-sec])",
    "ui.statusline.insert"           , "Statusline during insert mode (see [`editor.statusline`][e-sl-sec] & [`editor.color-modes`][e-sec])",
    "ui.statusline.normal"           , "Statusline during normal mode (see [`editor.statusline`][e-sl-sec] & [`editor.color-modes`][e-sec])",
    "ui.statusline.select"           , "Statusline during select mode (see [`editor.statusline`][e-sl-sec] & [`editor.color-modes`][e-sec])",
    "ui.statusline.separator"        , "Separator character in statusline (see [`editor.statusline`][e-sl-sec])",
    "ui.text"                        , "Command prompts, popup texts, etc.",
    "ui.text.focus"                  , "Focused text in commands prompts, popups (e.g. selected file in a file picker)",
    "ui.text.inactive"               , "Same as `ui.text` but when the text is inactive (e.g. suggestions)",
    "ui.text.info"                   , "Command text in `ui.popup.info` boxes",
    "ui.virtual"                     , "Fallback style for virtual text",
    "ui.virtual.indent-guide"        , "Vertical indent width guides (see [`editor.indent-guides`][e-ig-sec])",
    "ui.virtual.inlay-hint"          , "Default style for inlay hints of all kinds",
    "ui.virtual.inlay-hint.parameter", "Style for inlay hints of kind `parameter` (LSPs are not required to set a kind)",
    "ui.virtual.inlay-hint.type"     , "Style for inlay hints of kind `type` (LSPs are not required to set a kind)",
    "ui.virtual.ruler"               , "Ruler columns (see [`editor.rulers`][e-sec])",
    "ui.virtual.whitespace"          , "Visible whitespace characters (see [`editor.whitespace`][e-ws-sec])",
    "ui.virtual.wrap"                , "Soft-wrap indicator (see the [`editor.soft-wrap` config][e-sec])",
    "ui.window"                      , "Border lines separating splits in a window",

    // -- MIXED KEYS
    MIXED KEYS;

    // Markup, used in both UI and language
    "markup"           , "Default style for markup",
    "markup.heading"   , "Default heading style for markup",
    "markup.heading.1" , "Level 1 heading",
    "markup.heading.2" , "Level 2 heading",
    "markup.heading.3" , "Level 3 heading",
    "markup.heading.4" , "Level 4 heading",
    "markup.heading.5" , "Level 5 heading",
    "markup.heading.6" , "Level 6 heading",
    "markup.raw"       , "Raw markup",
    "markup.raw.inline", "Raw inline markup",

    // -- LANGUAGE ONLY KEYS
    LANGUAGE KEYS;

    // Language variants, in alphabetical order

    "attribute", "Class attributes, HTML tag attributes",
    "boolean"  , "Config values that are booleans, e.g. in SSH config files",
    "clean"    , "Used in the `Make` language",

    // Comments
    "comment"                    , "Default comment style",
    "comment.block"              , "Block comments (e.g. (`/* */`)",
    "comment.block.documentation", "Documentation block comments (e.g. (`/** */`)",
    "comment.discard"            , "Discarded comments", // Only used in Erlang
    "comment.documentation"      , "Documentation comments (e.g. `///` in Rust)",
    "comment.line"               , "Single line comments (`//`)",
    "comment.unused"             , "Unused comments",

    // Constant
    "constant"                 , "Default style for constants (TODO: `constant.other.placeholder` for `%v`)",
    "constant.builtin"         , "Builting constants provided by the language (`true`, `false`, `nil` etc)",
    "constant.builtin.boolean" , "Builtin booleans, e.g. `true`, `false` in Rust",
    "constant.builtin.numeric" , "Builtin numeric constant",
    "constant.character"       , "Character constant, e.g. `'a'` in Rust",
    "constant.character.escape", "Escaped character constant",
    "constant.macro"           , "Macro constant",
    "constant.numeric"         , "Numeric constants (numbers)",
    "constant.numeric.float"   , "Floating point constant",
    "constant.numeric.integer" , "Integer constant",

    // Constructor
    "constructor", "Constructor",

    // Diffs
    "diff"            , "Default style for diffs (see [`editor.gutters`][e-sec])",
    "diff.delta"      , "'Modified' diff",
    "diff.delta.moved", "'Moved' diff",
    "diff.minus"      , "'Removed' diff",
    "diff.plus"       , "'Added' diff",

    "embedded" , "Embedded",
    "exception", "Exception", // Used only in Lean
    "field"    , "Field", // Used only in Lean
    "file"     , "Config values that are files, e.g. in SSH config files",

    // Functions
    "function"               , "Default style for functions",
    "function.builtin"       , "Builtin functions",
    "function.call"          , "Function call", // only used in Lua
    "function.macro"         , "Macro functions",
    "function.method"        , "Methods",
    "function.method.builtin", "Builtin methods",
    "function.special"       , "Special functions",

    "identifier", "Config values that are identifiers, e.g. in SSH config files",
    "include"   , "Include", // Latex and Lean

    // Keywords
    "keyword"                     , "Default style for keywords",
    "keyword.control"             , "Control keywords",
    "keyword.control.conditional" , "Conditional control keywords, e.g. `if`, `else`, etc.",
    "keyword.control.exception"   , "Exception keywords, e.g. `try`, `raise`, etc.",
    "keyword.control.import"      , "Import/Include keywords, e.g. `use`, `include`, etc.",
    "keyword.control.repeat"      , "Loop keywords, e.g. `for`, `while`, etc.",
    "keyword.control.return"      , "Return keywords, e.g. `return`, `yield`, etc.",
    "keyword.directive"           , "Directives, e.g. `#include`, `comptime`, etc.",
    "keyword.function"            , "Function keywords, e.g. `fn`, `function`, etc.",
    "keyword.local"               , "Local keywords",
    "keyword.local.import"        , "Local imports keywords",
    "keyword.operator"            , "Operator keywords, e.g. `not`, `or`, etc.",
    "keyword.operator.assignment" , "Assignements keywords",
    "keyword.other"               , "Other keywords, without a clear category",
    "keyword.special"             , "Special keywords, like `unsafe` in Rust",
    "keyword.storage"             , "Default style for storage keywords",
    "keyword.storage.modifier"    , "Storage modifier keywords, e.g. `move`, `dyn`",
    "keyword.storage.modifier.mut", "Mutable storage modifier",
    "keyword.storage.modifier.ref", "Reference storage modifier",
    "keyword.storage.type"        , "Storage type keywords, e.g `class`, `let`",

    "label", "Labels",

    // Markup only used in languages
    "markup.bold"           , "Bold markup",
    "markup.heading.marker" , "Heading marker",
    "markup.inline"         , "Inline markup",
    "markup.italic"         , "Italic markup",
    "markup.label"          , "Label markup",
    "markup.link"           , "Link markup",
    "markup.link.label"     , "Link label markuo",
    "markup.link.text"      , "Link text markup",
    "markup.link.uri"       , "Link URI markup",
    "markup.link.url"       , "Link URL markup",
    "markup.list"           , "List markup",
    "markup.list.numbered"  , "Numbered list markup",
    "markup.list.unnumbered", "Unnumbered list markup",
    "markup.quote"          , "Quote markup",
    "markup.raw.block"      , "Raw block markup",
    "markup.strikethrough"  , "Strikethrough markup",
    "markup.underline"      , "Underline markup",

    "namespace", "Namespace",
    "none"     , "Used to reset highlighting in some queries",
    "number"   , "Config values that are numbers, e.g. in SSH config files",

    // Operator
    "operator"         , "Default style for operators, like `||`, `+=`, etc.",
    "operator.default" , "Default operator (not the same as `default`)",
    "operator.disjunct", "Disjunct operator, e.g. `|`",
    "operator.regexp"  , "Regex operator, e.g. `!~`, `=~`, etc.",
    "operator.unify"   , "Unify operator, e.g. `&`",

    // Punctuation
    "punctuation"               , "Default style for punctuation",
    "punctuation.bracket"       , "Brackets, e.g. `<`, `(`, `)`, etc.",
    "punctuation.definition"    , "Definition", // Only used in Svelte
    "punctuation.definition.tag", "Tag definition", // Only used in Svelte
    "punctuation.delimiter"     , "Delimiting punctuation, e.g. `,`, `::`",
    "punctuation.special"       , "Special punctuation, e.g. `{`, `}` in Python strings",

    "special", "Special",

    // Strings
    "string"                , "Default style for strings (TODO: `string.quoted.{single, double}`, `string.raw`/`.unquoted`)?",
    "string.escape"         , "Escaped string, e.g. in Markdown",
    "string.regexp"         , "Regex pattern string",
    "string.special"        , "Special string (meaning is language-specific)",
    "string.special.path"   , "Path string, used in git for example",
    "string.special.symbol" , "Symbol string",
    "string.special.uri"    , "URI string",
    "string.special.uri.url", "URL string (URLs are a special format of URIs)",

    "symbol", "Symbol",

    // Tags
    "tag"        , "Tag (e.g. `<body>` in HTML)",
    "tag.builtin", "Builtin language tag",
    "tag.error"  , "Erroneous tag, e.g. in HTML",

    // Text
    "text"        , "Default style for text (unset by almost all languages)", // Only used by Ledger
    "text.literal", "Text literal (see `text`)", // Only used by Ledger
    "time"        , "Config values that are time, e.g. in SSH config files",

    // Types
    "type"             , "Default style for types",
    "type.builtin"     , "Primitive types provided by the language (`int`, `usize`)",
    "type.enum"        , "Enum type",
    "type.enum.variant", "Enum variant",

    // Variables
    "variable"             , "Default style for variables",
    "variable.builtin"     , "Builtin variable (`self`, `this`, `super`, etc.)",
    "variable.other"       , "See `variable.other.member`",
    "variable.other.member", "Member variable",
    "variable.parameter"   , "Function parameter",

    "whole_identifier", "Identifier", // Only used in DHALL
);

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_generated_theme_table() {
        use std::path::Path;

        let workspace = Path::new(env!("CARGO_MANIFEST_DIR")).parent().unwrap();
        let generated = workspace
            .join("book")
            .join("src")
            .join("generated")
            .join("theme-table.md");

        let current_file = std::fs::read_to_string(&generated)
            .unwrap()
            .replace("\r\n", "\n");
        let new_gen = theme_keys_doc().replace("\r\n", "\n");

        if current_file != new_gen {
            panic!(
                "{} is not as expected, call `cargo xtask docgen` and rerun this test",
                generated.display()
            );
        }
    }
}
