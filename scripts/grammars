#! /usr/bin/env bash

set -e

GRAMMARS_DIR="$(dirname "$0")/../helix-syntax/languages"
REMOTE_NAME="helix-origin"

print_usage_and_exit() {
  echo "Usage: $0 <command>"
  echo ""
  echo "Commands:"
  echo ""
  echo "  status  Checks that each grammar is checked out at the revision in revisions.txt"
  echo "  sync    Ensures all grammars are cloned at the revisions in revisions.txt"
  echo "  clean   Removes all grammars from the grammars directory"
  echo ""
  exit 1
}

ensure_grammar_fetched() {
  local remote_url
  local grammar_dir
  local revision
  local current_remote_url
  local current_revision

  remote_url="$1"
  grammar_dir="${GRAMMARS_DIR}/$(basename "$1")"
  # trim trailing whitespace from the revision
  revision="$(echo -e "$2" | tr -d '[:space:]')"

  mkdir -p "${grammar_dir}"

  (
    set +e
    cd "${grammar_dir}"

    if [[ ! -d .git ]]; then
      git init
    fi

    current_remote_url="$(git remote get-url "$REMOTE_NAME" 2>/dev/null || echo -n "")"
    if [[ "${current_remote_url}" != "${remote_url}" ]]; then
      git remote set-url "${REMOTE_NAME}" "${remote_url}" 2>/dev/null || \
        git remote add "${REMOTE_NAME}" "${remote_url}"
    fi

    current_revision="$(git rev-parse HEAD 2>/dev/null)"
    if [[ "${current_revision}" != "${revision}" ]]; then
      # shallow clone at exact revision,
      # supported in git on the server-side since 2.5.0 (July of 2015), enabled
      # on GitHub by default
      git fetch "${REMOTE_NAME}" "${revision}" --depth=1
      git checkout "${revision}"
    fi
  )
  set -e
}

sync_grammars() {
  local grammar
  # revisions.txt has grammars separated by lines
  while read -r line; do
    # split each line on the space character
    IFS=' ' read -ra grammar <<< "${line}"
    # element 0 is the remote URL, element 1 is the revision
    ensure_grammar_fetched "${grammar[0]}" "${grammar[1]}"
  done <"$(dirname "$0")/./revisions.txt"
}

remove_all_grammars() {
  rm -rf "${GRAMMARS_DIR}"/tree-sitter-*
}

show_grammar_status() {
  local current_revision
  local grammar_name
  local are_any_out_of_date

  are_any_out_of_date=false

  set +e
  while read -r line; do
    IFS=' ' read -ra grammar <<< "${line}"
    grammar_name="$(basename "${grammar[0]}")"

    current_revision="$(
      cd "${GRAMMARS_DIR}/${grammar_name}"
      git rev-parse HEAD 2>/dev/null || echo -n ""
    )"

    if [[ "${current_revision}" != "${grammar[1]}" ]]; then
      are_any_out_of_date=true
      echo "${grammar_name} is out of date."
    fi
  done <"$(dirname "$0")/./revisions.txt"

  if [ "${are_any_out_of_date}" = "false" ]; then
    echo "All grammars are up to date."
  fi

  set -e
}

if [[ $# -eq 0 ]]; then
  print_usage_and_exit
fi

while (($#)); do
  __opt="$1"
  shift
  case "${__opt}" in
    sync)
      sync_grammars
      ;;

    clean)
      remove_all_grammars
      ;;

    status)
      show_grammar_status
      ;;

    *)
      print_usage_and_exit
      ;;
  esac
done
